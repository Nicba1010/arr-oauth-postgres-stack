services:
  traefik:
    image: traefik:v2
    command:
      - "--log.level=DEBUG"
      - "--api.insecure=true"

      - "--providers.docker=true"
      - "--providers.docker.exposedbydefault=false"

      - "--entrypoints.web.address=:80"
      - "--entrypoints.websecure.address=:443"

      - "--certificatesresolvers.default.acme.dnschallenge=true"
      - "--certificatesresolvers.default.acme.dnschallenge.provider=cloudflare"
      - "--certificatesresolvers.default.acme.dnschallenge.resolvers=1.1.1.1:53,1.0.0.1:53"
      - "--certificatesresolvers.default.acme.email=${LETSENCRYPT_EMAIL}"
      - "--certificatesresolvers.default.acme.storage=/letsencrypt/acme.json"
    environment:
      - CF_DNS_API_TOKEN=${CLOUDFLARE_API_TOKEN}
    ports:
      - "80:80"
      - "443:443"
      - "8080:8080"
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:ro
      - traefik_letsencrypt_cert_storage:/letsencrypt
    networks:
      - traefik_network
    restart: always

  prowlarr:
    image: lscr.io/linuxserver/prowlarr:latest
    environment:
      - PUID=1000
      - PGID=1000
      - TZ=${TZ:-Etc/UTC}
    volumes:
      - prowlarr_config:/config
    labels:
      - "traefik.enable=true"
      # Specify the network for Traefik to use
      - "traefik.docker.network=traefik_network"
      # Service definition
      - "traefik.http.services.prowlarr.loadbalancer.server.port=9696"
      # Router definition
      - "traefik.http.routers.prowlarr.rule=Host(`prowl.arr.${BASE_DOMAIN}`)"
      - "traefik.http.routers.prowlarr.entrypoints=websecure"
      - "traefik.http.routers.prowlarr.tls=true"
      - "traefik.http.routers.prowlarr.tls.certresolver=default"
      - "traefik.http.routers.prowlarr.service=prowlarr"
      - "traefik.http.routers.prowlarr.middlewares=prowlarr-auth"
      # Set priority lower than the OAuth router to ensure OAuth paths are handled first
      - "traefik.http.routers.prowlarr.priority=100"
    depends_on:
      prowlarr-postgres:
        condition: service_healthy
      prowlarr-config-patcher:
        condition: service_completed_successfully
    networks:
      - traefik_network
      - prowlarr_db_network
#    healthcheck:
#      test: curl -f http://localhost:9696/ping -s | jq -e 'select(.status == "OK")' > /dev/null || exit 1
#      interval: 30s
#      timeout: 5s
#      retries: 3
#      start_period: 20s
    restart: always

  prowlarr-config-patcher:
    build:
      context: ./arr_config_patcher
      dockerfile: Dockerfile
    volumes:
      - prowlarr_config:/config
    env_file:
      - ./default_postgres_vars.env
    environment:
      - POSTGRES_HOST=prowlarr-postgres
    restart: no

  prowlarr-postgres:
    image: postgres:${POSTGRES_IMAGE_TAG}
    env_file:
      - ./default_postgres_vars.env
    volumes:
      - prowlarr_db:/var/lib/postgresql/data
      - ./init_multiple_dbs.sh:/docker-entrypoint-initdb.d/init_multiple_dbs.sh
    healthcheck:
      test: [ "CMD", "pg_isready", "-U", "postgres" ]
      interval: 30s
      timeout: 5s
      retries: 3
      start_period: 5s
    networks:
      - prowlarr_db_network
    restart: always

  prowlarr-oauth2-proxy:
    image: quay.io/oauth2-proxy/oauth2-proxy:latest-alpine
    env_file:
      - ./default_oauth2_proxy_vars.env
    environment:
      - OAUTH2_PROXY_OIDC_ISSUER_URL=${PROWLARR_OIDC_ISSUER_URL}
      - OAUTH2_PROXY_CLIENT_ID=${PROWLARR_OIDC_CLIENT_ID}
      - OAUTH2_PROXY_CLIENT_SECRET=${PROWLARR_OIDC_CLIENT_SECRET}
      - OAUTH2_PROXY_COOKIE_SECRET=${PROWLARR_OIDC_COOKIE_SECRET}
      - OAUTH2_PROXY_REDIRECT_URL=https://prowl.arr.${BASE_DOMAIN}/oauth2/callback
    labels:
      - "traefik.enable=true"
      # Main auth middleware
      - "traefik.http.middlewares.prowlarr-auth.forwardauth.address=http://prowlarr-oauth2-proxy:4180"
      - "traefik.http.middlewares.prowlarr-auth.forwardauth.authResponseHeaders=X-Auth-Request-User,X-Auth-Request-Email,Authorization"
      # Service definition
      - "traefik.http.services.prowlarr-oauth2-proxy.loadbalancer.server.port=4180"
      # Router definition
      - "traefik.http.routers.prowlarr-oauth2-proxy.rule=Host(`prowl.arr.${BASE_DOMAIN}`) && PathPrefix(`/oauth2/`)"
      - "traefik.http.routers.prowlarr-oauth2-proxy.entrypoints=websecure"
      - "traefik.http.routers.prowlarr-oauth2-proxy.tls=true"
      - "traefik.http.routers.prowlarr-oauth2-proxy.tls.certresolver=default"
      - "traefik.http.routers.prowlarr-oauth2-proxy.service=prowlarr-oauth2-proxy"
      # Set priority higher than the main app router to ensure OAuth paths are handled first
      - "traefik.http.routers.prowlarr-oauth2-proxy.priority=110"
    networks:
      - traefik_network
    restart: always

  radarr:
    image: lscr.io/linuxserver/radarr:latest
    environment:
      - PUID=1000
      - PGID=1000
      - TZ=${TZ:-Etc/UTC}
    volumes:
      - radarr_config:/config
    labels:
      - "traefik.enable=true"
      # Specify the network for Traefik to use
      - "traefik.docker.network=traefik_network"
      # Service definition
      - "traefik.http.services.radarr.loadbalancer.server.port=7878"
      # Router definition
      - "traefik.http.routers.radarr.rule=Host(`rad.arr.${BASE_DOMAIN}`)"
      - "traefik.http.routers.radarr.entrypoints=websecure"
      - "traefik.http.routers.radarr.tls=true"
      - "traefik.http.routers.radarr.tls.certresolver=default"
      - "traefik.http.routers.radarr.service=radarr"
      - "traefik.http.routers.radarr.middlewares=radarr-auth"
      # Set priority lower than the OAuth router to ensure OAuth paths are handled first
      - "traefik.http.routers.radarr.priority=100"
    depends_on:
      radarr-postgres:
        condition: service_healthy
      radarr-config-patcher:
        condition: service_completed_successfully
    networks:
      - traefik_network
      - radarr_db_network
#    healthcheck:
#      test: curl -f http://localhost:7878/ping -s | jq -e 'select(.status == "OK")' > /dev/null || exit 1
#      interval: 30s
#      timeout: 5s
#      retries: 3
#      start_period: 20s
    restart: always

  radarr-config-patcher:
    build:
      context: ./arr_config_patcher
      dockerfile: Dockerfile
    volumes:
      - radarr_config:/config
    env_file:
      - ./default_postgres_vars.env
    environment:
      - POSTGRES_HOST=radarr-postgres
    restart: no

  radarr-postgres:
    image: postgres:${POSTGRES_IMAGE_TAG}
    env_file:
      - ./default_postgres_vars.env
    volumes:
      - radarr_db:/var/lib/postgresql/data
      - ./init_multiple_dbs.sh:/docker-entrypoint-initdb.d/init_multiple_dbs.sh
    healthcheck:
      test: [ "CMD", "pg_isready", "-U", "postgres" ]
      interval: 30s
      timeout: 5s
      retries: 3
      start_period: 5s
    networks:
      - radarr_db_network
    restart: always

  radarr-oauth2-proxy:
    image: quay.io/oauth2-proxy/oauth2-proxy:latest-alpine
    env_file:
      - ./default_oauth2_proxy_vars.env
    environment:
      - OAUTH2_PROXY_OIDC_ISSUER_URL=${RADARR_OIDC_ISSUER_URL}
      - OAUTH2_PROXY_CLIENT_ID=${RADARR_OIDC_CLIENT_ID}
      - OAUTH2_PROXY_CLIENT_SECRET=${RADARR_OIDC_CLIENT_SECRET}
      - OAUTH2_PROXY_COOKIE_SECRET=${RADARR_OIDC_COOKIE_SECRET}
      - OAUTH2_PROXY_REDIRECT_URL=https://rad.arr.${BASE_DOMAIN}/oauth2/callback
    labels:
      - "traefik.enable=true"
      # Main auth middleware
      - "traefik.http.middlewares.radarr-auth.forwardauth.address=http://radarr-oauth2-proxy:4180"
      - "traefik.http.middlewares.radarr-auth.forwardauth.authResponseHeaders=X-Auth-Request-User,X-Auth-Request-Email,Authorization"
      # Service definition
      - "traefik.http.services.radarr-oauth2-proxy.loadbalancer.server.port=4180"
      # Router definition
      - "traefik.http.routers.radarr-oauth2-proxy.rule=Host(`rad.arr.${BASE_DOMAIN}`) && PathPrefix(`/oauth2/`)"
      - "traefik.http.routers.radarr-oauth2-proxy.entrypoints=websecure"
      - "traefik.http.routers.radarr-oauth2-proxy.tls=true"
      - "traefik.http.routers.radarr-oauth2-proxy.tls.certresolver=default"
      - "traefik.http.routers.radarr-oauth2-proxy.service=radarr-oauth2-proxy"
      # Set priority higher than the main app router to ensure OAuth paths are handled first
      - "traefik.http.routers.radarr-oauth2-proxy.priority=110"
    networks:
      - traefik_network
    restart: always

  sonarr:
    image: lscr.io/linuxserver/sonarr:latest
    environment:
      - PUID=1000
      - PGID=1000
      - TZ=${TZ:-Etc/UTC}
    volumes:
      - sonarr_config:/config
    labels:
      - "traefik.enable=true"
      # Specify the network for Traefik to use
      - "traefik.docker.network=traefik_network"
      # Service definition
      - "traefik.http.services.sonarr.loadbalancer.server.port=8989"
      # Router definition
      - "traefik.http.routers.sonarr.rule=Host(`son.arr.${BASE_DOMAIN}`)"
      - "traefik.http.routers.sonarr.entrypoints=websecure"
      - "traefik.http.routers.sonarr.tls=true"
      - "traefik.http.routers.sonarr.tls.certresolver=default"
      - "traefik.http.routers.sonarr.service=sonarr"
      - "traefik.http.routers.sonarr.middlewares=sonarr-auth"
      # Set priority lower than the OAuth router to ensure OAuth paths are handled first
      - "traefik.http.routers.sonarr.priority=100"
    depends_on:
      sonarr-postgres:
        condition: service_healthy
      sonarr-config-patcher:
        condition: service_completed_successfully
    networks:
      - traefik_network
      - sonarr_db_network
#    healthcheck:
#      test: curl -f http://localhost:8989/ping -s | jq -e 'select(.status == "OK")' > /dev/null || exit 1
#      interval: 30s
#      timeout: 5s
#      retries: 3
#      start_period: 20s
    restart: always

  sonarr-config-patcher:
    build:
      context: ./arr_config_patcher
      dockerfile: Dockerfile
    volumes:
      - sonarr_config:/config
    env_file:
      - ./default_postgres_vars.env
    environment:
      - POSTGRES_HOST=sonarr-postgres
    restart: no

  sonarr-postgres:
    image: postgres:${POSTGRES_IMAGE_TAG}
    env_file:
      - ./default_postgres_vars.env
    volumes:
      - sonarr_db:/var/lib/postgresql/data
      - ./init_multiple_dbs.sh:/docker-entrypoint-initdb.d/init_multiple_dbs.sh
    healthcheck:
      test: [ "CMD", "pg_isready", "-U", "postgres" ]
      interval: 30s
      timeout: 5s
      retries: 3
      start_period: 5s
    networks:
      - sonarr_db_network
    restart: always

  sonarr-oauth2-proxy:
    image: quay.io/oauth2-proxy/oauth2-proxy:latest-alpine
    env_file:
      - ./default_oauth2_proxy_vars.env
    environment:
      - OAUTH2_PROXY_OIDC_ISSUER_URL=${SONARR_OIDC_ISSUER_URL}
      - OAUTH2_PROXY_CLIENT_ID=${SONARR_OIDC_CLIENT_ID}
      - OAUTH2_PROXY_CLIENT_SECRET=${SONARR_OIDC_CLIENT_SECRET}
      - OAUTH2_PROXY_COOKIE_SECRET=${SONARR_OIDC_COOKIE_SECRET}
      - OAUTH2_PROXY_REDIRECT_URL=https://son.arr.${BASE_DOMAIN}/oauth2/callback
    labels:
      - "traefik.enable=true"
      # Main auth middleware
      - "traefik.http.middlewares.sonarr-auth.forwardauth.address=http://sonarr-oauth2-proxy:4180"
      - "traefik.http.middlewares.sonarr-auth.forwardauth.authResponseHeaders=X-Auth-Request-User,X-Auth-Request-Email,Authorization"
      # Service definition
      - "traefik.http.services.sonarr-oauth2-proxy.loadbalancer.server.port=4180"
      # Router definition
      - "traefik.http.routers.sonarr-oauth2-proxy.rule=Host(`son.arr.${BASE_DOMAIN}`) && PathPrefix(`/oauth2/`)"
      - "traefik.http.routers.sonarr-oauth2-proxy.entrypoints=websecure"
      - "traefik.http.routers.sonarr-oauth2-proxy.tls=true"
      - "traefik.http.routers.sonarr-oauth2-proxy.tls.certresolver=default"
      - "traefik.http.routers.sonarr-oauth2-proxy.service=sonarr-oauth2-proxy"
      # Set priority higher than the main app router to ensure OAuth paths are handled first
      - "traefik.http.routers.sonarr-oauth2-proxy.priority=110"
    networks:
      - traefik_network
    restart: always

volumes:
  traefik_letsencrypt_cert_storage:
    driver: local
  prowlarr_config:
    driver: local
  prowlarr_db:
    driver: local
  radarr_config:
    driver: local
  radarr_db:
    driver: local
  sonarr_config:
    driver: local
  sonarr_db:
    driver: local


networks:
  traefik_network:
    name: traefik_network
    driver: bridge
    internal: false  # This network is accessible from outside
  prowlarr_db_network:
    name: prowlarr_db_network
    internal: true  # This network is not accessible from outside
  radarr_db_network:
    name: radarr_db_network
    internal: true  # This network is not accessible from outside
  sonarr_db_network:
    name: sonarr_db_network
    internal: true  # This network is not accessible from outside